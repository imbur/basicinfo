
Ezen fejezet témája a C nyelv nyelvtana lesz.

A következőben egy rövid forráskód-részleten keresztül mutatjuk be, hogy hogy néz ki egy C program. 


\clisting
%\begin{landscape}
\label{first_c_example}
%----------------------------------------------------------------------------
\lstinputlisting{codeexamples/first_c_example.c} 
%\end{landscape}

Az első soban egy úgynevezett \textbf{preprocesszor direktíva} található. A forráskód lefordítása során a tényleges fordítás előtt egy másik program(rész) is feldolgozza azt, ez a \textbf{preprocesszor}. A forráskódban azok a sorok, amelyek a preprocesszornak szólnak, jellemzően \#-al kezdődnek, ezeket feldolgozza, jellemzően valamilyen transzformációt hajt végre a forrásfájlon, majd ezt követően kerül sor annak tényleges lefordítására.

Jelen esetben egy \textbf{include direktívával} találkozunk, ez azt jelenti, hogy forráfájlunkban valamely másik fájl tartalmát is fel szeretnénk használni, ez most az stdio.h fájl, ami a szöveges I/O műveleteket támogató függvények deklarációját tartalmazza. A preprocesszor \emph{az include direktíva helyére ideiglenesen beilleszti a megjelölt fájl teljes tartalmát}, így a fordító ezt is benne fogja találni a forrásfájlunkban.

Léteznek egyéb preprocesszor direktívák is, ezekről később ejtünk szót.

A 3. és 4. sor egy-egy \textbf{függvénydeklarációt} tartalmaz. A C nyelvben a forráskódot úgynevezett \textbf{függvényekbe} szervezzük, csoportosítjuk, egy függvény általában egy bizonyos funkciót ellátó kódot fog össze. Ezeket azért hívjuk függvényeknek, mert futásuk során valamilyen \textbf{paraméterek} függvényében visszaadnak valamilyen \textbf{értéket} (amit visszatérési értéknek hívunk), hasonlóan a matematikában megszokott függvényekhez. Természetesen nem csak matematikai függvényekről lehet szó, bármilyen módon előállíthatják a visszatérési értéket, sőt, olyan függvény is elképzelhető, amelyik semmilyen visszatérési értékkel nem rendelkezik, ugyanígy a paraméterek száma is lehet 0, vagy akár tetszőlegesen sok.

A 3. és 4. sor csupán deklaráció, tehát a 3. sor jelentése a következő: ``valahol a kódban lesz majd egy olyan kódrészlet (egy függvényként), amelynek a paramétere két egész szám (angolul integer, ezt rövidítve a C nyelvben \textbf{int}), a visszatérési értéke szintén int, azaz egész szám, míg a neve ``osszead''. A deklarációt, mint minden C nyelvű utasítást egy pontosvessző zárja. Fontos, hogy ez a sor nem tartalmazza az ``osszead'' nevű függvény \textbf{implementációját}, azaz nem írja le, hogy a függvény ``mit is csinál'', csupán azt határozza meg, hogy milyen típusú paramétereket lehet neki átadni, illetve milyen típusú lesz a visszatérési értéke. A funkcionalitást leíró rész, azaz az implementáció, amit \textbf{függvénydefiníciónak} is nevezünk, később következik.

Hasonlóan, a 4. sorban található deklaráció jelentése: ``valahol a kódban (akár egy másik fájlban!) lesz majd egy függvény, aminek 0 darab paramétert lehet átadni és egy egész számot (int) ad vissza, neve pedig ``misztikusFuggveny''.

A 6. sorban egy úgynevezett megjegyzés, avagy \textbf{komment} található. Ezek olyan részek egy forráskódban, amelyeket a fordító figyelmen kívül hagy, funkciójuk csupán a kód működésének magyarázata, a megértés segítése. Azt, hogy egy kódsor kommentként értelmezendő, úgy jelezhetjük, hogy két darab / jelet teszünk az elejére. Forráskódunkban azokat a részeket, amik nem triviálisak, amelyek működése félreérthető, vagy sokat kell gondolkodni a megértéséhez, célszerű kommenttel ellátni, és tömören, lényegre törően leírni, hogy mi is történik ott és miért. Ennek azért van jelentősége, mert bár lehet, hogy mi értjük a saját magunk által írt kódot, de ha olyasvalakinek kell olvasnia és megértenie, aki nem ismeri (és ebbe mi is beletartozunk, ha például hónapok elteltével veszünk elő egy kódrészletet), nagy könnyebbséget jelent némi magyarázó szöveg. Fontos azonban, hogy ne írjunk felesleges kommenteket triviális kódrészletekhez, mert a megértést ebben az esetben érdemben nem segíti, ugyanakkor ha adott esetben módosítani kell a kódot, akkor többletmunkát jelent a kommentek módosítása is.

Az 7. sor egy \textbf{függvénydefiníció} kezdete, az úgynevezett fejléc. Itt a ``main'' nevű függvény definíciója kezdődik. A ``main'' egy speciális függvény, ugyanis a továbbiakban is minden programunkban lennie kell egynek, és amikor egy programot elindítunk, az a ``main'' függvénnyel kezdi a futását, ezt az operációs rendszer hívja meg (ezt \textbf{belépési pontnak} hívjuk). Paramétere jelen esetben nincs (ez nem mindig van így), a visszatérési értéke pedig egy egész szám, ami a gyakorlatban egy hibakód, ezzel lehet jelezni az operációs rendszer felé, hogy a program rendben lefutott, vagy esetleg valamilyen hiba történt. 

A függvény fejléce után kapcsos zárójelek között következik a \textbf{függvénytörzs}, ami a függvény meghívása során végrehajtandó kódot tartalmazza. A függvénytörzs sorai egymás után fognak végrehajtódni. 

Jelen esetben az 8-10. sor között három darab \textbf{változódeklaráció} található. Ezekkel azt fejezzük ki, hogy a függvénytörzsben használni fogunk három darab \textbf{változót}, amik gyakorlatilag olyan ``rekeszek'', amikben adategységeket tárolhatunk. Az egyes változók tartalma mögött az operatív memória egy-egy tartománya áll, tehát az értékek ott tárolódnak, azonban hogy milyen címen és milyen méretű (hány bájtos) memóriaterületen, azzal általában nem kell foglalkoznunk, a nyelv elfedi előlünk (ez alól természetesen majd lesznek kivételek). Az egyes változók típusa határozza meg egyrészt a változó tárolására használt memóriaterület méretét, másrészt útmutatást nyújt azzal kapcsolatban, hogy a benne tárolt adatok hogyan értelmezendőek. Esetünkben mindhárom \textbf{int}, azaz (előjeles) egész szám típusú, nevük pedig a, b és osszeg. Sajnos a C nyelv kellemetlen tulajdonsága, hogy nincsen rögzítve az alapvető típusok pontos mérete, de azt például tudjuk, hogy az int típus mérete jellemzően megegyezik azon processzorarchitektúra szóhosszúságával, amire fordították. Ezt sajnos tovább bonyolítja az, hogy például az Intel x86-64 architektúrájú processzorok (amelyek szóhosszúsága 64 bit) képesek olyan programokat is futtatni, amiket a régebbi, 32 bites szóhosszúságú Intel x86 architektúrára fordítottak, így ezeket a programokat hiába futtatjuk 64 bites processzoron, az int változók mérete továbbra is 32 bites lesz, ami pedig nyilvánvalóan meghatározza a bennük tárolható számok maximális (illetve minimális, hiszen negatív számokat is tárolhatunk) méretét.

\emph{A változók deklarációjakor még nem tudhatjuk, hogy ezekben a ``rekeszekben'' mi van, mi a számok értéke, jellemzően valamilyen véletlenszerű értéket vesznek fel} (a memóriában valaki által korábban ``ott felejtett'' érték, azaz \textbf{memóriaszemét}). Figyeljük meg, hogy ezeket a sorokat is egy-egy pontosvessző zárja.

A 12. és a 13. sor egy-egy \textbf{értékadást} tartalmaz. Jelentésük: ``az 'a' változó értéke legyen 5'', illetve ``a 'b' változó értéke legyen 3''. Mint minden utasítást, ezeket is pontosvessző zárja. Ha egy értékadás célja az, hogy egy változót valamilyen kezdeti értékkel lásson el (azaz hogy memóriaszemét helyett valamilyen értelmes, később használható értéket tároljon), a műveletet a változó \textbf{inicializálásának} is nevezhetjük.

A 15. sorban szintén egy értékadás található, itt azonban az ``osszeg'' változónak nem egy konstans értéket adunk, hanem azt írtuk utána, hogy ``osszead(a, b)''. Ez azt jelenti, hogy hívjuk meg (\textbf{függvényhívás}) az ``osszead'' függvényt, amit korábban deklaráltunk, és adjuk át neki első paraméterként az 'a' változót (aminek értéke ezen a helyen 5), illetve második paraméterként a 'b' változót, ami itt most 3 értéket vesz fel, majd azt az értéket, amivel ez visszatér, adjuk értékül az ``osszeg'' változónak.

Fontos, hogy ezen a ponton a fordító (mivel sorról sorra megy végig a forráskódon) nem tudja, hogy mit is csinál az ``oszead'' függvény, lehet, hogy összeadja a két paraméterét, és azt adja vissza, lehet, hogy elosztja az elsőt a másikkal, de az is lehet, hogy minden esetben 42-t ad vissza. A fordító csupán azt tudja, hogy létezik egy olyan függvény, aminek két egész számot lehet átadni paraméterként és egy egész szám a visszatérési értéke, hiszen a program első sorában lévő deklaráció csupán ennyi információt tartalmaz, ez azonban pont elég ahhoz, hogy ezt a kódot le tudja fordítani.

A 17. sor a main függvény \textbf{visszatérési utasítását} tartalmazza. Ez azt jelenti, hogy ha idáig eljut a program futása, akkor a main függvény térjen vissza, 0 visszatérési értékkel. Mivel a main függvény egy speciális függvény, amit az operációs rendszer hívott meg a program elindításakor, ez azt fogja jelenteni, hogy a program futása véget ér, és az operációs rendszer a futás eredményeként hibakódként a 0-t kapja, ami azt jelenti, hogy nem történt semmilyen hiba, a program rendben lefutott.

A 18. sorban a main függvény törzsét lezáró kapcsos zárójel van, a C nyelv szintaktikája előírja, hogy minden függvénytörzset egy ilyennel zárjunk le. 

A 20. és 21. sor szintén egy kommentet tartalmaz, ezúttal a másik lehetséges jelölést alkalmazva. Ha egy szövegrészt /*-el kezdünk és */-el fejezünk be, akkor a közöttük lévő teljes szöveg kommentként értelmeződik és nem szükséges az összes sor elejére a //-t kitenni. Ez akkor hasznos, ha hosszú, sok soros kommentet szeretnénk írni. 

A 22. sorban kezdődik az ``osszead'' függvény definíciója, szintén a fejléccel. Ez gyakorlatilag a deklaráció megismétlése, ahhoz képest többletinformációt nem hordoz (a deklarációra csak azért van szükség, mert ez a függvény a main függvény után helyezkedik el a kódunkban, így ahhoz, hogy a main függvény fordítható legyen, annak fordításakor a fordítónak már tudnia kell róla, hogy valahol később lesz egy ilyen nevű, paraméterezésű és visszatérési típusú, azaz röviden ilyen \textbf{szignatúrájú} függvényünk, ezt a technikát \textbf{elődeklarációnak} hívjuk).

Az ``osszead'' függvény függvénytörzse (amelyet egy nyitó kapcsos zárójelnek kell megelőznie) két soros. 

A 24. sor egy újabb függvényhívás (azaz egy, a main() függvényből meghívott függvényből újabb függvényeket hívhatunk meg, és ezt tetszőleges mélységig folytathatjuk), jelen esetben a misztikusFuggveny nevű függvényt hívjuk meg. Paramétert nem adunk át neki, mivel a függvény deklarációja megmondja, hogy ez a függvény nem fogad paramétereket és \emph{egy függvény meghívásakor mindig a deklaráció által előírt mennyiségű és típusú paramétereket kell átadnunk}. A függvénynek ugyanakkor van egy int típusú visszatérési értéke, ezt azonban nem kell feltétlenül felhasználnunk, meghívható a függvény anélkül, hogy a visszatérési értékét bárminek értékül adnánk, és le is fog futni, ha van valamilyen hatása a futásának, az meg fog történni, majd a visszatérési értéke egyszerűen elveszik.

A 26. sor egyben az osszead függvény visszatérési utasítása is, azt jelenti, hogy ``a függvény visszatérési értéke legyen az első paraméter (operandus1) és a második paraméter (operandus2) összege''. Tehát a függvény a nevének megfelelően összeadja a két paraméterként kapott egész számot, és az eredményt adja vissza, tehát a main-ben meghívva az ``osszeg'' változó értéke a 15. sorban 8 lesz. Az ``osszead'' függvény törzsét is kapcsos zárójel zárja.

A 29. sor egy újabb preprocesszor direktívát tartalmaz, láthatjuk, hogy kettős kereszt (hashmark) áll a sor elején. Ez pedig a \textbf{define direktíva}. Több esetben is használható, mi most egy konstanst definiálunk vele, aminek a példában látható szintaktikával a neve TOMB\textunderscore HOSSZ, értéke pedig 10. A direktívát a preprocesszor úgy kezeli, hogy a kód további részében a definiált kulcsszót (TOMB\textunderscore HOSSZ) mindenhol kicseréli az utána írt értékre (10-re). Nem csak számot definiálhatunk így, hanem bármilyen szöveget, ennek egészen bonyolult alkalmazásai lehetnek, igen összetett logikákat lehet define-okkal ``összetrükközni'', azonban mint azt később látni fogjuk, ez bizonyos esetekben veszélyes lehet, így sokszor érdemes egyéb megoldást keresni helyette.

Amire most mi használjuk, arra viszont tökéletesen megfelel, később az így definiált konstanst (TOMB\textunderscore HOSSZ) hasonlóan kezelhetjük, mint egy egész típusú változót, annyi különbséggel, hogy értéket nem adhatunk neki, és nem szabad elfelejtenünk, hogy a behelyettesítés még a forráskód tényleges lefordítása előtt történik, tehát ahova mi azt írjuk, hogy TOMB\textunderscore HOSSZ, ott a fordító azt fogja látni, hogy 10. Mégis igen hasznos ilyen formában definiálni értékeket, egyrészt azért, mert ``beszédesebbé'' teszik a kódot, mint ha közvetlenül számokat írnánk bele, másrészt segítik a karbantartását is, hiszen ha később kitaláljuk, hogy az az érték, amire most TOMB\textunderscore HOSSZ néven gondolunk legyen 10 helyett például 20, akkor elég egy helyen, a define direktívánál átírni, így kevesebb az extra munka, kevesebb a hibalehetőség.

A 31. sorban a misztikusFuggveny definíciója kezdődik, hasonlóan, mint az osszead függvénynél, a fejléccel.

A 33. sorban egy ismerős kifejezést látunk, ami egy változódeklarációhoz hasonlít, azonban a változó neve után egy szögletes zárójelben az áll, hogy TOMB\textunderscore HOSSZ. Az előbb leírt módon, mivel a TOMB\textunderscore HOSSZ egy preprocesszor direktívával definiált konstans, a preprocesszor a helyére 10-et fog behelyettesíteni, azaz a fordítás pillanatában a változó neve után 10 fog állni a szögeletes zárójelben. Ezzel a szintaktikával azt fejezhetjük ki, hogy egy tömböt szeretnénk deklarálni. A \textbf{tömb} egy olyan \textbf{adatstruktúra}, ami \emph{azonos típusú változókból, a memóriában folytonosan (egymás után) tárol} valahány darabot. Azt, hogy hány darabot tárol, a tömb \textbf{elemszáma} határozza meg, és ez az, amit a tömb deklarációjakor a szögletes zárójelbe írunk.

Jelen esetben egy olyan tömböt deklarálunk, aminek a neve ``szamok'', és TOMB\textunderscore HOSSZ darab (azaz 10 darab) int típusú (azaz előjeles egész) értéket tárol.

Természetesen a tömb elemeit el kell érnünk valahogyan, tehát hivatkozni kell rájuk, hasonlóan, mint az egyes változókra. Annyiban bonyolultabb a helyzet a tömbökkel, hogy amíg a változókat a nevükkel azonosíthatjuk a kódban, a tömbökre ez nem igaz, hiszen egy tömb több elemet is tárol, így valamilyen kiegészítő információ szükséges az egyes elemek eléréséhez. Erre az a megoldás, hogy ha egy tömb n. elemére szeretnénk hivatkozni, akkor a tömb neve után szögletes zárójelben oda kell írni n-et. Így a szamok nevű tömb 5. elemét például úgy érjük el, hogy szamok[5]. A szögletes zárójelbe írt értéket \textbf{indexnek}, az ilyen módon történő hivatkozást pedig \textbf{indexelésnek} nevezzük.

Fontos megjegyezni, hogy \emph{a tömbök elemei minden esetben 0-tól számozódnak}, tehát például ha a szamok tömb 10 elemű, akkor a legális indexek a [0..9] intervallumból kerülnek ki, így a szamok[10] módon hivatkozott érték már nem része a tömbnek, hanem egy azon kívüli, ismeretlen tartalmú és ``tulajdonosú'' memóriaterület, így arról olvasni memóriaszemetet fogunk, oda írni pedig a program (illetve speciális esetben az egész számítógép) működésének veszélyeztetésével jár, így szigorúan tilos. Ráadásul a szamok[10] kifejezés szintaktikailag helyes, így a fordító nem fog hibát jelezni rá, a hiba csak futás közben jelentkezik, így programok írásakor különösen figyelnünk kell arra, hogy tömböket csak legális indexekkel indexeljünk (azaz elkerüljük a \textbf{túlcímzést}, avagy \textbf{túlindexelést}).

A 34. és 35. sor egy-egy már korábban is látott változódeklarációt tartalmaz, annyi különbséggel, hogy most a deklarációval egy sorban megtörténik az egyik változó (magikusSzam) kezdeti értékének beállítása (inicializálás) is.

A 37. sorban egy \textbf{ciklus} kezdődik. A ciklus (hasonlóan egy függvényhez) két részből, a \textbf{ciklusfejből} és a \textbf{ciklustörzsből} áll.

A ciklusok \textbf{vezérlési szerkezetek}, és több fajtájuk van, ezek egyike a \textbf{for ciklus} (számláló ciklus), egy ilyennek a ciklusfeje látható a 37. sorban. A ciklusfej elején a for kulcsszó jelöli, hogy egy for ciklusról lesz szó, majd egy zárójelet követően a for ciklusok fejének (fejlécének) három, pontosvesszővel elválasztott, eltérő funkciójú része.

A nyitó zárójel után, de az első pontosvessző előtt található rész fut le először. A példánkban itt az i változó inicializálása történik, és a gyakorlatban ilyen jellegű kódot szokás ide írni, de természetesen bármilyen szintaktikailag helyes kód elhelyezhető itt.

A következő részben (a két pontosvessző között) egy feltételnek kell szerepelnie, azaz egy olyan kifejezésnek, ami valamilyen logikai értékre (igaz, vagy hamis) értékelődik ki. Később látni fogjuk, hogy a C-ben \emph{minden kifejezésnek van valamilyen logikai értéke}, de mégis praktikus valamilyen szemléletes, feltétel jellegű kifejezést írni ide, a kód könnyű megérthetőségét elősegítendő. A példában az ``i < TOMB\textunderscore HOSSZ'' kifejezés szerepel itt, ami logikai IGAZ értékű, ha i kisebb, mint TOMB\textunderscore HOSSZ, ha pedig egyenlő, vagy nagyobb, akkor logikai HAMIS értékű.

A for ciklus úgy működik, hogy a ciklustörzsben lévő kódot újra és újra végrehajtja, egészen addig, amíg a ciklusfej feltétel része logikai IGAZ értékű, ekkor befejeződik, és a kód végrehajtása a ciklus után folytatódik. 

A ciklusfej harmadik részébe írt kód a ciklustörzs minden egyes végrehajtása \textbf{után} hajtódik végre, ide most egy olyan utasítást írtunk, ami az i változó értékét növeli 1-el. 

Ennek megfelelően a teljes ciklus úgy fog működni, hogy először az i változó értékét 0-ra állítja, majd megvizsgálja a feltételt, ha IGAZ értékű, akkor végrehajtja a ciklustörzset, ezt követően végrehajtja a ciklusfej harmadik részét (azaz növeli az i változó értékét), ismét kiértékeli a feltételt, ha IGAZ, újra végrehajtja a ciklustörzset, újra növeli i-t, stb\ldots

Könnyen belátható, hogy mivel az i változó 0-ra inicializálódik és TOMB\textunderscore HOSSZ-nál kell kisebbnek lennie ahhoz, hogy a ciklustörzs lefusson, a ciklustörzs pontosan 10-szer fog lefutni, és i értéke eközben 0,1,2,\ldots,9 lesz, és jelen esetben pontosan ez a célunk.

A for ciklust nagyon gyakran használjuk olyankor, amikor azt szeretnénk elérni, hogy egy kódrészlet bizonyos számú alkalommal fusson le egymás után, mivel kényelmes ilyen konstrukciókat implementálni a segítségével (ezért is nevezzük számláló ciklusnak). Amennyiben (egyébként igen bevett módon) egy változó növelünk minden egyes iterációjában a ciklusnak, azt a változót (jelen esetben i-t) \textbf{ciklusváltozónak} nevezzük.

A ciklustörzset (hasonlóan a függvénytörzsekhez) kapcsos zárójelek közé zárjuk, így jelöljük azt a kódot, amit a ciklus keretében többször is végre kell hajtani.
Példánkban egyetlen sor kód szerepel a ciklustörzsben, ez a 39. sor. A már korábban említett módon hivatkozás történik a szamok nevű tömb elemeire, méghozzá úgy, hogy a tömböt a ciklusváltozóval (i-vel) indexeljük. Láttuk, hogy a ciklus futása során i változó értéke a [0..(TOMB\textunderscore HOSSZ - 1)] intervallumot járja be, ez azt jelenti, hogy minden egyes iterációban a tömb egy-egy elemére hivatkozunk így, és előbb-utóbb sorra kerül a tömb összes eleme.

Ez az utasítás egy értékadás, és az érték, ami a tömb egyes elemeinek értékül adódik egy összetett (szorzásból és összeadásból álló) algebrai művelet eredményeként áll elő, amiben szerepel a ciklusváltozó is, így a teljes ciklus lefutása után a tömb egyes elemei eltérő értékűek lesznek (10, 13, 16, 19\ldots).

Láthattuk, hogy tömböket bejárni, az egyes elemein műveleteket végezni számláló ciklussal lehet kényelmesen és biztonságosan, azonban nem ez az egyetlen ciklusfajta a C nyelvben.

A 42. sorban 0-ra állítjuk az i változó értékét, majd a 44. sor egy új kulcsszóval, a while-al kezdődik. Ez a kulcsszó egy másik típusú ciklus, a \textbf{while ciklus} fejlécének kezdetét jelöli. Szintaktikája egyszerűbb, mint a for ciklusnak, a fejlécben a while kulcsszó után zárójelben csupán egy feltételt kell megadni, hasonlóan, mint a for ciklus fejlécének a középső részében, és amíg ez a feltétel IGAZ logikai értékű, addig a ciklustörzs végrehajtódik újra és újra.

A ciklustörzs első utasítása elsőre furcsa lehet, a += operátort találjuk benne, ez annyit tesz, hogy az előtte álló változó értékét megnöveljük az utána álló kifejezés értékével. Hasonló módon működnek a -=, *=, /=, és hasonló operátorok.

A ciklustörzs jelentése tehát az, hogy a korábban 0-ra inicializált magikusSzam nevű változót megnöveljük a szamok nevű tömb i. elemének értékével. Ahhoz, hogy megértsük, hogy miért hasznos ez, tekintsük a ciklustörzs másik utasítását is. Ez (i++;) i változó értékét növeli egyel (hasonlóan, az i--; azt jelentené, hogy i változó értékét csökkentjük egyel).

Ha figyelembe vesszük, hogy a while ciklus előtt az i változó értékét 0-ba állítottuk, majd egy, a for cikluséval azonos feltételt írtunk a while ciklus fejlécébe, végül pedig a ciklustörzs utolsó utasításaként megnöveltük az i változó értékét, könnyen rájöhetünk, hogy a két ciklus ugyanúgy egyesével bejárja a szamok tömb elemeit (igaz, mást csinál velük), ugyanakkor látható, hogy a for ciklus ezt tömörebben, kifejezőbben teszi meg (az összes, ciklus helyes működtetéséhez szükséges művelet a fejlécben van leírva), így az ilyen jellegű feladatokhoz ezt célszerű választani, azonban a különböző ciklusok bár eltérő szintaktikát követelnek meg, általánosan is kiválthatják egymást. Példának okáért egy for ciklus, aminek csak a feltétel részébe írunk valamit, gyakorlatilag egy while ciklus.

Az 51. sorban a printf függvény meghívása látható. A \textbf{printf} függvényt korábban nem deklaráltuk, így felmerül a kérdés, hogy a fordító miért nem jelez rá hibát, hogyan tudja mégis lefordítani ezt a kódrészletet. Erre a megoldás az, hogy a printf egy úgynevezett \textbf{könyvtári függvény}, amit nem nekünk kell implementálni, mások megtették előttünk, és a fejlesztőkörnyezetünk tartalmazza a deklarációját egy úgynevezett header-fájlban, amit stdio.h-nak hívnak, és a programunk első sorában jeleztük, hogy szeretnénk, ha a fordító ennek a tartalmát is felhasználná. \emph{A függvény implementációja nincs benne az stdio.h fájlban, azonban a szignatúrája (név, paraméterek típusai, visszatérési típus, hasonlóan az előre deklarált függvényeinkhez) igen, és ez éppen elég ahhoz, hogy a fordító le tudja fordítani a kódunkat}. A printf függvény a szöveges konzolra írja ki a paraméterként kapott szöveget (string-et, azaz karakterfüzért), a pontos működéséről később lesz szó. Most elegendő annyit tudnunk, hogy ez a sor kiírja a konzolra a mágikus számunkat.

Mintaprogramunk 53. sorától egy újabb vezérlési szerkezetet láthatunk, ez azonban nem ciklus, hanem egy \textbf{feltételes elágazás}. Az if kulcsszó után egy feltételt adhatunk meg, ami ha IGAZ értékű, akkor végrehajtódnak a következő kapcsos zárójelekkel határolt blokkban lévő utasítások, ha HAMIS, akkor pedig nem.
Opcionálisan, az else kulcsszóval megadhaunk egy második utasítás-blokkot is, ami pedig csak akkor fog lefutni, ha az if utáni blokk nem futott le, azaz ha a feltétel HAMIS értékű volt.

Példánkban mindkét utasítás-blokkban egy-egy visszatérési utasítás van, azonban eltérő visszatérési értékkel. Ez demonstrálja azt, hogy egy függvény futása több ponton is véget érhet, \emph{egy függvénynek tetszőleges számú kilépési pontja lehet}, azonban gondoskodni kell róla, hogy amennyiben van valamilyen visszatérési értéke a függvénynek, minden esetben ráfusson előbb-utóbb egy return utasításra.



